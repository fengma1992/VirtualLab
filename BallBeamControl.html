<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>球杆模型控制实验</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<div class="mainDiv">
    <canvas id="mainCanvas" width="1000" height="400"></canvas>
    <div class="rowFlexDiv">
        <div class="columnFlexDiv">
            <span>小球位置曲线</span>
            <canvas id="positionCanvas" width="500" height="300"></canvas>
        </div>
        <div class="columnFlexDiv">
            <span>杆角度曲线</span>
            <canvas id="angleCanvas" width="500" height="300"></canvas>
        </div>
    </div>
    <div class="rowFlexDiv">
        <canvas id="ADDCanvas" width="45" height="45"></canvas>
        <canvas id="PIDCanvas" width="45" height="45"></canvas>
        <canvas id="BallBeamCanvas" width="60" height="45"></canvas>
    </div>
    <div class="rowFlexDiv">
        <div>
            <span class="normalSpan">P:</span><input type="number" id="PInput" value="20" class="PIDInput">
        </div>
        <div>
            <span class="normalSpan">I:</span><input type="number" id="IInput" value="0" class="PIDInput">
        </div>
        <div>
            <span class="normalSpan">D:</span><input type="number" id="DInput" value="20" class="PIDInput">
        </div>
        <span id="positionSpan" class="normalSpan">选定位置:0</span>
        <button id="startBtn" class="normalBtn" onclick="start()">开始</button>
        <button id="resetBtn" class="normalBtn" onclick="reset()">重置</button>
    </div>
    <div id="loadingDiv" class="loadingDiv">
        <img class="loadingImg" src="img/loading.gif" alt="loading">
    </div>
</div>
<script src="js/VILibraries/ADDVI.js"></script>
<script src="js/VILibraries/PIDVI.js"></script>
<script src="js/VILibraries/BallBeamVI.js"></script>
<script src="js/VILibraries/WaveVI.js"></script>
<script src="js/three.js"></script>
<script src="js/MTLLoader.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/ObjectControls.js"></script>

<script>
    var loadingDiv = document.getElementById('loadingDiv');
    var mainCanvas = document.getElementById('mainCanvas');
    var positionCanvas = document.getElementById('positionCanvas');
    var angleCanvas = document.getElementById('angleCanvas');
    var ADDCanvas = document.getElementById('ADDCanvas');
    var PIDCanvas = document.getElementById('PIDCanvas');
    var BallBeamCanvas = document.getElementById('BallBeamCanvas');
    var positionSpan = document.getElementById('positionSpan');
    var PInput = document.getElementById('PInput');
    var IInput = document.getElementById('IInput');
    var DInput = document.getElementById('DInput');
    var startBtn = document.getElementById('startBtn');

    //3D部分变量
    var camera, scene, renderer, controls, markControl, beam, ball, mark;

    var requestAnimationFrame = window.requestAnimationFrame
            || window.mozRequestAnimationFrame
            || window.webkitRequestAnimationFrame
            || window.msRequestAnimationFrame;
    window.requestAnimationFrame = requestAnimationFrame;

    //VI部分变量
    var positionWave = new WaveVI(positionCanvas);
    var angleWave = new WaveVI(angleCanvas);
    var addVI = new AddVI(ADDCanvas);
    var PIDVI = new PIDVI(PIDCanvas);
    var ballBeamVI = new BallBeamVI(BallBeamCanvas);
    var position = 0;
    var runFlag = false;
    var timer;

    addVI.autoSave = false;
    PIDVI.autoSave = false;

    function start() {

        if (!runFlag) {

            runFlag = !runFlag;
            startBtn.innerText = '暂停';
            position = mark.position.x;
            addVI.originalInput = position;
            PIDVI.P = PInput.value;
            PIDVI.I = IInput.value;
            PIDVI.D = DInput.value;
            timer = window.setInterval(onTimer, 30);

        }
        else {

            runFlag = !runFlag;
            startBtn.innerText = '开始';
            window.clearInterval(timer);

        }

    }

    function onTimer() {

        //加法器
        addVI.setData(ballBeamVI.position);//输入球位置信号，输出位置偏差
        //PID控制器
        PIDVI.setData(addVI.singleOutput);//输入位置偏差，输出杆角度
        //球杆模型
        ballBeamVI.setInputAngle(PIDVI.singleOutput);//输入杆角度信号，输出调整角度与位置
        //波形控件
        positionWave.setData(ballBeamVI.positionOutput, ballBeamVI.dataLength);
        angleWave.setData(ballBeamVI.angelOutput, ballBeamVI.dataLength);
        //球杆3D场景
        setPosition(ballBeamVI.PIDAngle * Math.PI / 180, ballBeamVI.PIDPosition);

    }

    function setPosition(ang, pos) {
        var angle = -ang;//角度为逆时针旋转
        beam.rotation.z = angle;
        ball.rotation.z = angle;
        mark.rotation.z = angle;
        ball.position.y = pos * Math.sin(angle);
        ball.position.x = pos * Math.cos(angle);
        mark.position.y = position * Math.sin(angle);
        mark.position.x = position * Math.cos(angle);
    }

    function reset() {

        runFlag = false;
        startBtn.innerText = '开始';
        window.clearInterval(timer);
        addVI.reset();
        PIDVI.reset();
        ballBeamVI.reset();
        position = 0;
        setPosition(0, 0);
    }

    init();

    function init() {

        renderer = new THREE.WebGLRenderer({
            canvas: mainCanvas,
            antialias: true
        });
        renderer.setClearColor(0x6495ED);
        renderer.setSize(mainCanvas.clientWidth, mainCanvas.clientHeight);

        camera = new THREE.PerspectiveCamera(30, mainCanvas.clientWidth / mainCanvas.clientHeight, 1, 100000);
        camera.position.z = 400;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.rotateSpeed = 0.8;
        controls.enableZoom = true;
        controls.zoomSpeed = 1.2;
        controls.enableDamping = true;

        scene = new THREE.Scene();


        var light = new THREE.AmbientLight(0x555555);
        scene.add(light);
        var light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(4000, 4000, 4000);
        scene.add(light1);
        var light2 = new THREE.DirectionalLight(0xffffff, 1);
        light2.position.set(-4000, 4000, -4000);
        scene.add(light2);

        //use as a reference plane for ObjectControl
        var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(1000, 400));

        markControl = new ObjectControls(camera, renderer.domElement);
        markControl.map = plane;
        markControl.offsetUse = true;

        markControl.attachEvent('mouseOver', function () {
            this.container.style.cursor = 'pointer';
        });

        markControl.attachEvent('mouseOut', function () {
            this.container.style.cursor = 'auto';
        });

        markControl.attachEvent('dragAndDrop', onMouseDrag);

        markControl.attachEvent('mouseUp', function () {
            controls.enabled = true;
            this.container.style.cursor = 'auto';
        });


        var mtlLoader = new THREE.MTLLoader();
        var objLoader = new THREE.OBJLoader();

        loadingDiv.style.display = 'flex';
        mtlLoader.load('assets/BallBeamControl/base.mtl', function (materials) {

            materials.preload();

            objLoader.setMaterials(materials);
            objLoader.load('assets/BallBeamControl/base.obj', function (base) {
                base.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {

                        child.material.side = THREE.DoubleSide;
                    }
                });
                mtlLoader.load('assets/BallBeamControl/beam.mtl', function (materials) {

                    materials.preload();

                    objLoader.setMaterials(materials);
                    objLoader.load('assets/BallBeamControl/beam.obj', function (b) {
                        b.traverse(function (child) {
                            if (child instanceof THREE.Mesh) {

                                child.material.side = THREE.DoubleSide;
                            }
                        });
                        beam = b;
                        mtlLoader.load('assets/BallBeamControl/ball.mtl', function (materials) {

                            materials.preload();

                            objLoader.setMaterials(materials);
                            objLoader.load('assets/BallBeamControl/ball.obj', function (c) {
                                c.traverse(function (child) {
                                    if (child instanceof THREE.Mesh) {

                                        child.material.side = THREE.DoubleSide;
                                    }
                                });
                                ball = c;
                                mtlLoader.load('assets/BallBeamControl/mark.mtl', function (materials) {

                                    materials.preload();

                                    objLoader.setMaterials(materials);
                                    objLoader.load('assets/BallBeamControl/mark.obj', function (d) {
                                        d.traverse(function (child) {
                                            if (child instanceof THREE.Mesh) {

                                                child.material.side = THREE.DoubleSide;
                                            }
                                        });
                                        mark = d;
                                        loadingDiv.style.display = 'none';
                                        scene.add(base);
                                        scene.add(beam);
                                        scene.add(ball);
                                        scene.add(mark);
                                        markControl.attach(mark);
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
        animate();
    }

    function onMouseDrag() {

        controls.enabled = false;
        this.container.style.cursor = 'move';
        this.focused.position.y = this.previous.y;  //lock y direction
        var positionX = this.focused.position.x;
        if (positionX < -120)
            this.focused.position.x = -120;
        else if (positionX > 120)
            this.focused.position.x = 120;

        positionX = this.focused.position.x;
        positionSpan.innerText = '选定位置：' + positionX.toFixed(2);
    }

    function animate() {

        window.requestAnimationFrame(animate);
        markControl.update();
        controls.update();
        renderer.render(scene, camera);

    }

</script>
</body>
</html>